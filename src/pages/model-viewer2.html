<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2BHK 3D Model Viewer - SoleEstate</title>
    <link rel="stylesheet" href="../styles/main.scss">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        
        #model-container {
            width: 100%;
            height: 100vh;
            background-color: #f5f5f5;
        }
        
        .controls-panel {
            background-color: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 8px;
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            width: 250px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        
        .back-button {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 10px 15px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            text-decoration: none;
            color: #0d6efd;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .back-button:hover {
            background-color: rgba(240, 240, 240, 0.9);
        }
        
        @media (max-width: 768px) {
            .controls-panel {
                position: absolute;
                bottom: 20px;
                top: auto;
                right: 20px;
                width: calc(100% - 40px);
                max-width: 400px;
            }
        }
    </style>
</head>
<body>
    <!-- Back Button Only -->
    <a href="floor-plan.html" class="back-button">
        <i class="fas fa-arrow-left"></i> Back to Floor Plans
    </a>
    
    <!-- Controls Panel -->
    <div class="controls-panel">
        <h5 id="model-title">2BHK 3D Floor Plan</h5>
        <div class="mb-3">
            <label for="view-mode" class="form-label">View Mode</label>
            <select class="form-select" id="view-mode">
                <option value="3d">3D View</option>
                <option value="top">Top View</option>
                <option value="front">Front View</option>
                <option value="side">Side View</option>
                <option value="interior">Interior View</option>
            </select>
        </div>
        <div class="form-check form-switch mb-3">
            <input class="form-check-input" type="checkbox" id="show-wireframe">
            <label class="form-check-label" for="show-wireframe">Show Wireframe</label>
        </div>
        <div class="form-check form-switch mb-3">
            <input class="form-check-input" type="checkbox" id="show-interior-lights" checked>
            <label class="form-check-label" for="show-interior-lights">Interior Lighting</label>
        </div>
        <div class="mb-3">
            <label for="rotation-speed" class="form-label">Rotation Speed</label>
            <input type="range" class="form-range" id="rotation-speed" min="0" max="5" step="0.1" value="0">
        </div>
        <button class="btn btn-sm btn-primary" id="reset-camera">Reset View</button>
    </div>
    
    <!-- 3D Model Container -->
    <div id="model-container"></div>

    <!-- Add Three.js libraries -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    
    <!-- 3D Model Viewer Script -->
    <script>
        // Initialize variables for Three.js
        let scene, camera, renderer, controls, model;
        let rotationSpeed = 0;
        const modelPath = '../assets/models/2bhk.glb';
        
        // Initialize the 3D scene
        function initViewer() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf5f5f5);

            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(5, 5, 5);

            // Create renderer
            const container = document.getElementById('model-container');
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            // Add lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Add orbit controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.25;

            // Load the 3D model
            loadModel();

            // Handle window resize
            window.addEventListener('resize', onWindowResize);
        }

        // Load 3D model
        function loadModel() {
            const loader = new THREE.GLTFLoader();
            
            loader.load(
                modelPath,
                function (gltf) {
                    model = gltf.scene;
                    
                    // Center the model
                    const box = new THREE.Box3().setFromObject(model);
                    const center = box.getCenter(new THREE.Vector3());
                    model.position.x = -center.x;
                    model.position.y = -center.y;
                    model.position.z = -center.z;
                    
                    // Scale the model if needed
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    if (maxDim > 10) {
                        const scale = 10 / maxDim;
                        model.scale.set(scale, scale, scale);
                    }
                    
                    // Enhance materials for interior visualization
                    model.traverse(function(child) {
                        if (child.isMesh) {
                            // Enable shadows
                            child.castShadow = true;
                            child.receiveShadow = true;
                            
                            // Improve material quality if needed
                            if (child.material) {
                                // If the material doesn't have good lighting properties
                                if (!child.material.roughness) {
                                    child.material.roughness = 0.7;
                                }
                                if (!child.material.metalness) {
                                    child.material.metalness = 0.2;
                                }
                            }
                        }
                    });
                    
                    scene.add(model);
                    
                    // Add additional interior lighting
                    addInteriorLighting();
                    
                    // Position camera to see the model
                    const distance = Math.max(size.x, size.z) * 2;
                    camera.position.set(distance, distance / 2, distance);
                    camera.lookAt(0, 0, 0);
                    controls.update();
                },
                function (xhr) {
                    console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                },
                function (error) {
                    console.error('An error happened', error);
                    // Create a fallback model if loading fails
                    createFallbackModel();
                }
            );
        }

        // Add interior lighting to enhance the model
        function addInteriorLighting() {
            // Add a soft ambient light for interior
            const interiorAmbient = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(interiorAmbient);
            
            // Add point lights to simulate interior lighting
            const pointLight1 = new THREE.PointLight(0xffffcc, 1.2, 20);
            pointLight1.position.set(0, 5, 0);
            pointLight1.castShadow = true;
            pointLight1.name = "interiorLight1"; // Add name for identification
            scene.add(pointLight1);
            
            // Add a second light for better interior coverage
            const pointLight2 = new THREE.PointLight(0xffffcc, 0.8, 15);
            pointLight2.position.set(-5, 3, -5);
            pointLight2.castShadow = true;
            pointLight2.name = "interiorLight2"; // Add name for identification
            scene.add(pointLight2);
            
            // Add a third light for even better coverage
            const pointLight3 = new THREE.PointLight(0xffffcc, 0.8, 15);
            pointLight3.position.set(5, 3, 5);
            pointLight3.castShadow = true;
            pointLight3.name = "interiorLight3"; // Add name for identification
            scene.add(pointLight3);
        }
        
        // Create a fallback model if loading fails
        function createFallbackModel() {
            // Create a simple house shape with 2BHK layout
            const group = new THREE.Group();
            
            // Floor
            const floorGeometry = new THREE.BoxGeometry(12, 0.2, 12);
            const floorMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.position.y = -0.1;
            floor.receiveShadow = true;
            group.add(floor);
            
            // Walls
            const wallMaterial = new THREE.MeshStandardMaterial({ color: 0xeeeeee });
            
            // Back wall
            const backWallGeometry = new THREE.BoxGeometry(12, 3, 0.2);
            const backWall = new THREE.Mesh(backWallGeometry, wallMaterial);
            backWall.position.set(0, 1.5, -6);
            backWall.castShadow = true;
            backWall.receiveShadow = true;
            group.add(backWall);
            
            // Front wall with door hole
            const frontWallGroup = new THREE.Group();
            
            const frontWallLeft = new THREE.Mesh(
                new THREE.BoxGeometry(5, 3, 0.2),
                wallMaterial
            );
            frontWallLeft.position.set(-3.5, 1.5, 0);
            frontWallLeft.castShadow = true;
            frontWallLeft.receiveShadow = true;
            frontWallGroup.add(frontWallLeft);
            
            const frontWallRight = new THREE.Mesh(
                new THREE.BoxGeometry(5, 3, 0.2),
                wallMaterial
            );
            frontWallRight.position.set(3.5, 1.5, 0);
            frontWallRight.castShadow = true;
            frontWallRight.receiveShadow = true;
            frontWallGroup.add(frontWallRight);
            
            const frontWallTop = new THREE.Mesh(
                new THREE.BoxGeometry(2, 1, 0.2),
                wallMaterial
            );
            frontWallTop.position.set(0, 2.5, 0);
            frontWallTop.castShadow = true;
            frontWallTop.receiveShadow = true;
            frontWallGroup.add(frontWallTop);
            
            frontWallGroup.position.set(0, 0, 6);
            group.add(frontWallGroup);
            
            // Left wall with window
            const leftWallGroup = new THREE.Group();
            
            const leftWallBottom = new THREE.Mesh(
                new THREE.BoxGeometry(0.2, 1, 12),
                wallMaterial
            );
            leftWallBottom.position.set(0, 0.5, 0);
            leftWallBottom.castShadow = true;
            leftWallBottom.receiveShadow = true;
            leftWallGroup.add(leftWallBottom);
            
            const leftWallTop = new THREE.Mesh(
                new THREE.BoxGeometry(0.2, 1, 12),
                wallMaterial
            );
            leftWallTop.position.set(0, 2.5, 0);
            leftWallTop.castShadow = true;
            leftWallTop.receiveShadow = true;
            leftWallGroup.add(leftWallTop);
            
            const leftWallLeft = new THREE.Mesh(
                new THREE.BoxGeometry(0.2, 1, 4),
                wallMaterial
            );
            leftWallLeft.position.set(0, 1.5, -4);
            leftWallLeft.castShadow = true;
            leftWallLeft.receiveShadow = true;
            leftWallGroup.add(leftWallLeft);
            
            const leftWallRight = new THREE.Mesh(
                new THREE.BoxGeometry(0.2, 1, 4),
                wallMaterial
            );
            leftWallRight.position.set(0, 1.5, 4);
            leftWallRight.castShadow = true;
            leftWallRight.receiveShadow = true;
            leftWallGroup.add(leftWallRight);
            
            leftWallGroup.position.set(-6, 0, 0);
            group.add(leftWallGroup);
            
            // Right wall
            const rightWallGeometry = new THREE.BoxGeometry(0.2, 3, 12);
            const rightWall = new THREE.Mesh(rightWallGeometry, wallMaterial);
            rightWall.position.set(6, 1.5, 0);
            rightWall.castShadow = true;
            rightWall.receiveShadow = true;
            group.add(rightWall);
   
            // Interior elements
            
            // Interior walls (room dividers for 2BHK)
            const interiorWallGeometry1 = new THREE.BoxGeometry(6, 3, 0.1);
            const interiorWallMaterial = new THREE.MeshStandardMaterial({ color: 0xf5f5f5 });
            const interiorWall1 = new THREE.Mesh(interiorWallGeometry1, interiorWallMaterial);
            interiorWall1.position.set(0, 1.5, 0);
            interiorWall1.castShadow = true;
            interiorWall1.receiveShadow = true;
            group.add(interiorWall1);
            
            // Second bedroom divider
            const interiorWallGeometry2 = new THREE.BoxGeometry(0.1, 3, 6);
            const interiorWall2 = new THREE.Mesh(interiorWallGeometry2, interiorWallMaterial);
            interiorWall2.position.set(3, 1.5, -3);
            interiorWall2.castShadow = true;
            interiorWall2.receiveShadow = true;
            group.add(interiorWall2);
            
            // Living room furniture
            
            // Sofa
            const sofaGroup = new THREE.Group();
            
            // Sofa base
            const sofaBaseGeometry = new THREE.BoxGeometry(3, 0.5, 1);
            const sofaMaterial = new THREE.MeshStandardMaterial({ color: 0x6b8e23 });
            const sofaBase = new THREE.Mesh(sofaBaseGeometry, sofaMaterial);
            sofaBase.position.y = 0.25;
            sofaBase.castShadow = true;
            sofaBase.receiveShadow = true;
            sofaGroup.add(sofaBase);
            
            // Sofa back
            const sofaBackGeometry = new THREE.BoxGeometry(3, 1, 0.3);
            const sofaBack = new THREE.Mesh(sofaBackGeometry, sofaMaterial);
            sofaBack.position.set(0, 0.75, -0.35);
            sofaBack.castShadow = true;
            sofaBack.receiveShadow = true;
            sofaGroup.add(sofaBack);
            
            // Sofa arms
            const sofaArmGeometry = new THREE.BoxGeometry(0.3, 0.7, 1);
            const sofaArmLeft = new THREE.Mesh(sofaArmGeometry, sofaMaterial);
            sofaArmLeft.position.set(-1.35, 0.35, 0);
            sofaArmLeft.castShadow = true;
            sofaArmLeft.receiveShadow = true;
            sofaGroup.add(sofaArmLeft);
            
            const sofaArmRight = new THREE.Mesh(sofaArmGeometry, sofaMaterial);
            sofaArmRight.position.set(1.35, 0.35, 0);
            sofaArmRight.castShadow = true;
            sofaArmRight.receiveShadow = true;
            sofaGroup.add(sofaArmRight);
            
            sofaGroup.position.set(-3, 0, 3);
            group.add(sofaGroup);
            
            // Coffee table
            const tableGroup = new THREE.Group();
            
            // Table top
            const tableTopGeometry = new THREE.BoxGeometry(1.5, 0.1, 1);
            const tableMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
            const tableTop = new THREE.Mesh(tableTopGeometry, tableMaterial);
            tableTop.position.y = 0.5;
            tableTop.castShadow = true;
            tableTop.receiveShadow = true;
            tableGroup.add(tableTop);
            
            // Table legs
            const tableLegGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.5);
            const tableLegMaterial = new THREE.MeshStandardMaterial({ color: 0x5c3a21 });
            
            const positions = [
                [-0.65, 0.25, -0.4],
                [0.65, 0.25, -0.4],
                [-0.65, 0.25, 0.4],
                [0.65, 0.25, 0.4]
            ];
            
            positions.forEach(position => {
                const tableLeg = new THREE.Mesh(tableLegGeometry, tableLegMaterial);
                tableLeg.position.set(...position);
                tableLeg.castShadow = true;
                tableLeg.receiveShadow = true;
                tableGroup.add(tableLeg);
            });
            
            tableGroup.position.set(-3, 0, 1);
            group.add(tableGroup);
            
            // Master Bedroom
            const bedGroup1 = new THREE.Group();
            
            // Bed base
            const bedBaseGeometry = new THREE.BoxGeometry(2, 0.3, 3);
            const bedBaseMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
            const bedBase = new THREE.Mesh(bedBaseGeometry, bedBaseMaterial);
            bedBase.position.y = 0.15;
            bedBase.castShadow = true;
            bedBase.receiveShadow = true;
            bedGroup1.add(bedBase);
            
            // Mattress
            const mattressGeometry = new THREE.BoxGeometry(1.9, 0.2, 2.9);
            const mattressMaterial = new THREE.MeshStandardMaterial({ color: 0xf5f5f5 });
            const mattress = new THREE.Mesh(mattressGeometry, mattressMaterial);
            mattress.position.y = 0.4;
            mattress.castShadow = true;
            mattress.receiveShadow = true;
            bedGroup1.add(mattress);
            
            // Pillow
            const pillowGeometry = new THREE.BoxGeometry(0.6, 0.1, 0.4);
            const pillowMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const pillow = new THREE.Mesh(pillowGeometry, pillowMaterial);
            pillow.position.set(0, 0.55, -1.2);
            pillow.castShadow = true;
            pillow.receiveShadow = true;
            bedGroup1.add(pillow);
            
            // Blanket
            const blanketGeometry = new THREE.BoxGeometry(1.9, 0.05, 1.5);
            const blanketMaterial = new THREE.MeshStandardMaterial({ color: 0x4682b4 });
            const blanket = new THREE.Mesh(blanketGeometry, blanketMaterial);
            blanket.position.set(0, 0.53, 0.2);
            blanket.castShadow = true;
            blanket.receiveShadow = true;
            bedGroup1.add(blanket);
            
            bedGroup1.position.set(4, 0, -4);
            group.add(bedGroup1);
            
            // Second Bedroom
            const bedGroup2 = new THREE.Group();
            
            // Bed base (smaller)
            const bedBase2 = new THREE.Mesh(
                new THREE.BoxGeometry(1.8, 0.3, 2.5),
                bedBaseMaterial
            );
            bedBase2.position.y = 0.15;
            bedBase2.castShadow = true;
            bedBase2.receiveShadow = true;
            bedGroup2.add(bedBase2);
            
            // Mattress (smaller)
            const mattress2 = new THREE.Mesh(
                new THREE.BoxGeometry(1.7, 0.2, 2.4),
                mattressMaterial
            );
            mattress2.position.y = 0.4;
            mattress2.castShadow = true;
            mattress2.receiveShadow = true;
            bedGroup2.add(mattress2);
            
            // Pillow
            const pillow2 = new THREE.Mesh(
                new THREE.BoxGeometry(0.5, 0.1, 0.3),
                pillowMaterial
            );
            pillow2.position.set(0, 0.55, -1);
            pillow2.castShadow = true;
            pillow2.receiveShadow = true;
            bedGroup2.add(pillow2);
            
            // Blanket
            const blanket2 = new THREE.Mesh(
                new THREE.BoxGeometry(1.7, 0.05, 1.2),
                new THREE.MeshStandardMaterial({ color: 0x20b2aa })
            );
            blanket2.position.set(0, 0.53, 0.2);
            blanket2.castShadow = true;
            blanket2.receiveShadow = true;
            bedGroup2.add(blanket2);
            
            bedGroup2.position.set(4, 0, 3);
            group.add(bedGroup2);
            
            // Kitchen counter
            const counterGroup = new THREE.Group();
            
            // Counter base
            const counterBaseGeometry = new THREE.BoxGeometry(3, 0.9, 1);
            const counterMaterial = new THREE.MeshStandardMaterial({ color: 0x696969 });
            const counterBase = new THREE.Mesh(counterBaseGeometry, counterMaterial);
            counterBase.position.y = 0.45;
            counterBase.castShadow = true;
            counterBase.receiveShadow = true;
            counterGroup.add(counterBase);
            
            // Counter top
            const counterTopGeometry = new THREE.BoxGeometry(3.2, 0.1, 1.2);
            const counterTopMaterial = new THREE.MeshStandardMaterial({ color: 0xf5f5f5 });
            const counterTop = new THREE.Mesh(counterTopGeometry, counterTopMaterial);
            counterTop.position.y = 0.95;
            counterTop.castShadow = true;
            counterTop.receiveShadow = true;
            counterGroup.add(counterTop);
            
            // Sink
            const sinkGeometry = new THREE.BoxGeometry(0.8, 0.1, 0.6);
            const sinkMaterial = new THREE.MeshStandardMaterial({ color: 0xc0c0c0 });
            const sink = new THREE.Mesh(sinkGeometry, sinkMaterial);
            sink.position.set(0.5, 0.96, 0);
            sink.castShadow = true;
            sink.receiveShadow = true;
            counterGroup.add(sink);
            
            counterGroup.position.set(-3, 0, -3);
            group.add(counterGroup);
            
            // Dining table
            const diningGroup = new THREE.Group();
            
            // Table top
            const diningTableGeometry = new THREE.BoxGeometry(1.8, 0.1, 1.8);
            const diningTableMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
            const diningTable = new THREE.Mesh(diningTableGeometry, diningTableMaterial);
            diningTable.position.y = 0.75;
            diningTable.castShadow = true;
            diningTable.receiveShadow = true;
            diningGroup.add(diningTable);
            
            // Table leg
            const diningLegGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.75);
            const diningLeg = new THREE.Mesh(diningLegGeometry, diningTableMaterial);
            diningLeg.position.y = 0.375;
            diningLeg.castShadow = true;
            diningLeg.receiveShadow = true;
            diningGroup.add(diningLeg);
            
            // Chairs
            const chairPositions = [
                [0, 0, -1],
                [0, 0, 1],
                [-1, 0, 0],
                [1, 0, 0]
            ];
            
            chairPositions.forEach(position => {
                const chairGroup = new THREE.Group();
                
                // Chair seat
                const chairSeatGeometry = new THREE.BoxGeometry(0.5, 0.1, 0.5);
                const chairMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
                const chairSeat = new THREE.Mesh(chairSeatGeometry, chairMaterial);
                chairSeat.position.y = 0.45;
                chairSeat.castShadow = true;
                chairSeat.receiveShadow = true;
                chairGroup.add(chairSeat);
                
                // Chair back
                const chairBackGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.1);
                const chairBack = new THREE.Mesh(chairBackGeometry, chairMaterial);
                chairBack.position.set(0, 0.7, -0.25);
                chairBack.castShadow = true;
                chairBack.receiveShadow = true;
                chairGroup.add(chairBack);
                
                // Chair legs
                const chairLegGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.45);
                const chairLegMaterial = new THREE.MeshStandardMaterial({ color: 0x5c3a21 });
                
                const legPositions = [
                    [-0.2, 0.225, -0.2],
                    [0.2, 0.225, -0.2],
                    [-0.2, 0.225, 0.2],
                    [0.2, 0.225, 0.2]
                ];
                
                legPositions.forEach(legPos => {
                    const chairLeg = new THREE.Mesh(chairLegGeometry, chairLegMaterial);
                    chairLeg.position.set(...legPos);
                    chairLeg.castShadow = true;
                    chairLeg.receiveShadow = true;
                    chairGroup.add(chairLeg);
                });
                
                chairGroup.position.set(...position);
                
                // Rotate chair to face table
                if (position[0] < 0) chairGroup.rotation.y = Math.PI / 2;
                if (position[0] > 0) chairGroup.rotation.y = -Math.PI / 2;
                if (position[2] < 0) chairGroup.rotation.y = 0;
                if (position[2] > 0) chairGroup.rotation.y = Math.PI;
                
                diningGroup.add(chairGroup);
            });
            
            diningGroup.position.set(0, 0, 3);
            group.add(diningGroup);
            
            // Add the group to the scene
            model = group;
            scene.add(model);
            
            // Position camera
            camera.position.set(15, 10, 15);
            camera.lookAt(0, 0, 0);
            controls.update();
        }
        
        // Handle window resize
        function onWindowResize() {
            const container = document.getElementById('model-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Apply rotation if enabled
            if (model && rotationSpeed > 0) {
                model.rotation.y += rotationSpeed * 0.01;
            }
            
            controls.update();
            renderer.render(scene, camera);
        }
        
        // Handle view mode changes
        document.getElementById('view-mode').addEventListener('change', function() {
            const mode = this.value;
            
            if (!model) return;
            
            // Get model dimensions
            const box = new THREE.Box3().setFromObject(model);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.z) * 1.5;
            
            if (mode === '3d') {
                camera.position.set(maxDim, maxDim / 2, maxDim);
            } else if (mode === 'top') {
                camera.position.set(0, maxDim * 1.5, 0);
            } else if (mode === 'front') {
                camera.position.set(0, 0, maxDim * 1.5);
            } else if (mode === 'side') {
                camera.position.set(maxDim * 1.5, 0, 0);
            } else if (mode === 'interior') {
                // Position camera inside the model for interior view
                camera.position.set(0, 1.6, 0); // Average human eye height
                camera.lookAt(2, 1.6, 0); // Look forward
            }
            
            camera.lookAt(center);
            controls.update();
        });
        
        // Toggle wireframe mode
        document.getElementById('show-wireframe').addEventListener('change', function() {
            const wireframeEnabled = this.checked;
            
            if (!model) return;
            
            model.traverse(function(child) {
                if (child.isMesh && child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(mat => {
                            mat.wireframe = wireframeEnabled;
                        });
                    } else {
                        child.material.wireframe = wireframeEnabled;
                    }
                }
            });
        });
        
        // Toggle interior lights
        document.getElementById('show-interior-lights').addEventListener('change', function() {
            const lightsOn = this.checked;
            
            // Find all point lights (interior lights)
            scene.traverse(function(object) {
                if (object.isPointLight && object.name && object.name.includes("interiorLight")) {
                    object.visible = lightsOn;
                    console.log(`Light ${object.name} visibility set to ${lightsOn}`);
                }
            });
        });
        
        // Handle rotation speed changes
        document.getElementById('rotation-speed').addEventListener('input', function() {
            rotationSpeed = parseFloat(this.value);
        });
        
        // Reset camera view
        document.getElementById('reset-camera').addEventListener('click', function() {
            if (!model) return;
            
            const box = new THREE.Box3().setFromObject(model);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());
            
            const distance = Math.max(size.x, size.z) * 2;
            camera.position.set(distance, distance / 2, distance);
            camera.lookAt(center);
            controls.update();
        });
        
        // Initialize the viewer
        initViewer();
        animate();
    </script>
</body>
</html>